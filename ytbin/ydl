#!/bin/sh
#
# yt-dlp wrapper, embeds select metadata and notifies.
#  retrieve with:
#  exiftool "$1" -Comment -s3 -j | jq -r '.[].Comment|fromjson|.key'
#  exiftool "$1" -Comment -s3 -j \
#  | jq '.[].Comment|fromjson|.Comments[]| "\(.author):\n    \(.text)\n"' -r \
#  | fmt -w $(($(tput cols) - 4 )) | nvim -c 'set ft=comments' -match '^@\w.*:$'

usage() {
    echo "Usage: ydl -[c|clip|-clipboard] <yt_link>"
    echo "Options:"
    echo "  -c, -clip, -clipboard  Download from clipboard"
    exit 1
}

sndnotif() {
    TITLE="${NOTIFICATION_ID:-YT Download}"
    MESSAGE="$1"
    ICON="${2:-$HOME/Pictures/icons/dunst_icons/youtube.png}"
    notify-send -a "ydl" -r 9999 \
        -i "$ICON" \
        -h "string:x-canonical-private-synchronous:$NOTIFICATION_ID" \
        -u normal "$TITLE" "$MESSAGE"
    printf "%s\n%s" "$TITLE" "$MESSAGE"
}

cleanup() {
    for arg in "$@"; do
        [ -f "$arg" ] || [ -S "$arg" ] || continue
        rm -f "$arg" 2>/dev/null
    done
    return 0
}

match() {
    dir="$1" ; name="$2" ; ext="3" ; match=$(find "$dir" -type f -iname "$name.$ext" | head -n1)
    [ -f "$match" ] && realpath "$match" || return 1;
    return 0
}


# Download video thumbnail and selected metadata
getthumb() {
    thumbnail="$1"
    out="$2"
    [ -n "$thumbnail" ] || { echo "No thumbnail link!" ; return 1 ; }
    raw=$(mktemp --suffix=".webp");
    wget -q "$thumbnail" -O "$raw" || { echo "Thumbnail download failed."; rm -f "$raw"; exit 1; }
    magick "$raw" -fuzz 10% -trim +repage -quality 100 "$out.jpg";
    [ -f "$out.jpg" ] && rm -f "$raw" || return 1;
    return 0 ;
}

embedthumb() {
    img="$1"
    json_data=${2:-"$json_data"}
    [ -f "img" ] || { echo "No image file" ; return 1 ; }
    [ -f "$json_data" ] || [ -z "$json_data" ] && { echo "No or empty json file" ; return 1 ; }
    exiftool -m -q -overwrite_original -UserComment="$json_data" "$img" || \
       { echo "Thumbnail metadata embedding failed." return 1 ; }
    return 0 ;
}

jsonextract() {
    src="$1"  
    out="$2"
    dt=$(date +"%Y-%m-%d %H:%M:%S")
    cf="~cf." 
    jq '.' -r "$src" | jq --arg uri "$LINK" --arg dldate "$dt" --arg cf "$cf" '
    {
            Title: .title,
            Date: .upload_date,
            Duration: .duration_string,
            URI: (.webpage_url // $uri),
            ID: .id,
            Thumbnail: .thumbnail,
            Description: .description,
            Uploader: .uploader,
            Resolution: .resolution,
            LikeCount: .like_count,
            ViewCount: .view_count,
            CommentCount: .comment_count,
            Channel: .channel,
            ChannelFollowerCount: .channel_follower_count,
            ChannelURL: .channel_url,
            ChannelID: .channel_id,
            UploaderID: .uploader_id,
            UploaderURL: .uploader_url,
            UploadDate: .upload_date,
            Timestamp: .timestamp,
            Playlist: (.playlist? // ""),
            PlaylistIndex: (.playlist_index? // ""),
            Subtitles: (.subtitles | {english: (.en? // []), french: (.fr? // [])}),
            Categories: (.categories[]?| select(. != "")),
            Tags: [ .tags[]?| select(. != "") ],
            Chapters: [ .chapters[]? | {start_time, title} ],
            Comments: (
            .comments | map(select(
            .author_is_uploader == true
            or .is_pinned == true
            or .like_count >= 10
            or .text != ""))
            | sort_by(.timestamp)
            | reverse
            | .[:100]
            | map({
            id: .id,
            author: .author,
            author_thumbnail: .author_thumbnail,
            author_url: .author_url,
            since: ._time_text,
            timestamp: .timestamp,
            text: .text,
            like_count: .like_count,
            is_pinned: .is_pinned,
            author_is_uploader: .author_is_uploader
        })),
        DownloadDate: $dldate,
        Signature: $cf
    }' >"$out" 
    return 0 ;
}

embed_audio() { 
    audio_f="$1"
    json_data="$2"
    thumbjpg="$3"
    tmp_f=$(mktmp --suffix=.opus);
    ffmpeg -i "$audio_f" -i "$thumbjpg" -metadata comment="$json_data" -c:a copy -c:v mjpeg -disposition:v attached_pic "$tmp_f"
    if [ -f "$tmp_f" ] && mv "$tmp_f" "$audio_f"; then
        sndnotif "ðŸ˜ $title." "$thumbjpg"
        cleanup "$json_f" "$info_json" "$PIPE" "$json_f"
        return 0
    else
        sndnotif "ðŸ˜ž $title audio download failed during metadata embedding."
        cleanup "$PIPE" >/dev/null
        return 1
    fi
}

embed() {
    video_f="$1"
    json_f="$2"
    thumbjpg="$3"
    ext="${video_f##*.}"
    title=$(basename "$video_f" ".$ext")
    tmp_f=$(mktemp --suffix=".$ext")
    json_data=$(jq '.' -r "$json_f")
    if ffmpeg -i "$video_f" -metadata comment="${json_data}" -codec copy "$tmp_f" >"$LOGS_PATH/$title.log" 2>&1 ; then
        mv "$tmp_f" "$video_f" -f && notify-send -a "ydl" -r 8888 -i "$thumbjpg" "$title"  "c'fait. ðŸ˜ "
        rm "$json_f" "$info_json" 
    else
        notify-send -a "ydl" -r 8888 -i "$thumbjpg" "ðŸ˜ž $title metadata embedding failed."
        {   # [dbg]
            # echo "json_data: $json_data"
            echo "video_f:   $video_f"
            echo "ext_f:     $ext"
            echo "thumbjpg:  $thumbjpg"
            echo "tmp_file:  $tmp_f"
            echo "json_f:    $json_f"
            echo "info_json: $info_json"
            echo "PIPE:      $PIPE"
            echo "LINK:      $LINK"
            echo "title:     $title"
            echo "DOWNLOAD_PATH: $DOWNLOAD_PATH"
            echo "AUDIO_ONLY:    $AUDIO_ONLY"
        } >"$HOME/Videos/downloads/logs/$title.fail.log"
        return 1
    fi
}

DOWNLOAD_PATH="$HOME/Videos/downloads"
LOGS_PATH="$DOWNLOAD_PATH/logs"

[ -d "$LOGS_PATH" ] || mkdir -p "$LOGS_PATH"
[ -d "$DOWNLOAD_PATH" ] || mkdir -p "$DOWNLOAD_PATH"

[ $# -eq 0 ] && usage

AUDIO_ONLY=0
IS_PLAYLIST=0

case "$1" in
    -h|--help|help)
        usage
        ;;
    -c|-clip|-clipboard|--clipboard)
        LINK="$(xclip -selection clipboard -o)"
        ;;
    -a|-audio|--audio-only)
        AUDIO_ONLY=1
        LINK="$2"
        ;;
    *)
        LINK="$1"
        ;;
esac

PIPE=$(mktemp)

# Download video, capture the filename
if [ $AUDIO_ONLY -eq 1 ]; then
    yt-dlp -o "$DOWNLOAD_PATH/%(title)s.%(ext)" "$LINK" -q --no-warnings --write-comments --write-info-json --extract-audio --audio-format opus | tee "$PIPE" &
else
    case "$LINK" in 
        *youtube.com/playlist?list*)
            IS_PLAYLIST=1 ;
            yt-dlp -o "$DOWNLOAD_PATH/%(uploader)s/%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s" "$LINK" --quiet --no-warnings --write-comments --write-info-json 2>&1 | tee "$PIPE" & 
            NOTIFICATION_ID="$title"
            [ -z "$NOTIFICATION_ID" ] && NOTIFICATION_ID="YT Download"
            sndnotif "Downloading..."
            yt-dlp "$LINK"  --get-title --get-thumbnail | while read -r t i; do
                if [ -n "$t" ] && [ -n "$i" ]; then
                    thumb="$DOWNLOAD_PATH/$t.jpg"
                    getthumb "$i" "$DOWNLOAD_PATH/$t.jpg" && \
                    [ -f "$thumb" ] && notify-send -a "ydl" -r 8888 -t 2000 -i "$thmb" "$t" "Downloading.."
                else
                    continue
                fi 
            done 2>&1 | tee "$PIPE" &
            ;;

        *) title=$(yt-dlp "$LINK" --get-title)
           thumbnail=$(yt-dlp "$LINK"  --get-thumbnail)
           NOTIFICATION_ID="$title"
           [ -z "$NOTIFICATION_ID" ] && NOTIFICATION_ID="YT Download"
           sndnotif "Downloading..."
           if [ -n "$title" ] && [ -n "$thumbnail" ]; then
                thmb="$DOWNLOAD_PATH/$title.jpg"
                getthumb "$thumbnail" "$thmb" && \
                    [ -f "$thmb" ] && notify-send -a "ydl" -r 8888 -t 2000 -i "$thmb" "$title" "Downloading.."
                yt-dlp -o "$DOWNLOAD_PATH/%(uploader)s/%(title)s.%(ext)s" "$LINK" --quiet --no-warnings --write-comments --write-info-json 2>&1 | tee "$PIPE" &
           else
               notify-send "Error downloading."
               return 1;
           fi
           ;;
    esac
fi


while IFS= read -r line; do
    sndnotif "$line"
done < "$PIPE" 2>/dev/null

wait

if [ $IS_PLAYLIST -eq 1 ]; then  
    titles=$(yt-dlp --get-title "$LINK")
    for title in $titles ; do
        info_json="$DOWNLOAD_PATH/$title.info.json"
        [ -f "$info_json" ] || info_json=$(match "$DOWNLOAD_PATH" "$title" "info.json") || exit 1 ; 
        json_f="$DOWNLOAD_PATH/$title.json" 
        video=$(find "$DOWNLOAD_PATH" -type f -iname "$title.*" | grep -v "$title.\(json\|info.json\|jpg\|log\|fail.log\)")
        thumbjpg="$DOWNLOAD_PATH/$title.jpg"
        if [ -f "$thumbjpg" ]; then
            if jsonextract "$info_json" "$json_f"; then 
                [ -f "$json_f" ] && embedthumb "$$thumbjpg" "$json_f"
            else
                getthumb "$(jq .thumbnail "$info_json")" "$thumbjpg" && jsonextract "$info_json" "$json_f"
            fi
            [ -f "$video" ] && embed "$video" "$json_f" "$thumbjpg" 
        fi 
    done
else
    title=$(yt-dlp --get-title "$LINK")
    info_json="$DOWNLOAD_PATH/$title.info.json"
    [ -f "$info_json" ] || info_json=$(match "$DOWNLOAD_PATH" "$title" "info.json") || exit 1 ; 
    json_f="$DOWNLOAD_PATH/$title.json" 
    thumbjpg="$DOWNLOAD_PATH/$title.jpg"
    [ -f "$thumbjpg" ] || getthumb "$(jq .thumbnail "$info_json")" "$thumbjpg"
    if  jsonextract "$info_json" "$json_f"; then  
        [ -f "$json_f" ] && [ -f "$thumbjpg" ] && embedthumb "$$thumbjpg" "$json_f"
        if [ "$AUDIO_ONLY" -eq 1 ]; then 
            f="$DOWNLOAD_PATH/$title.opus" 
            [ -f "$f" ] && embed_audio "$f" "$json_f" "$thumbjpg" || return 1 
            cleanup "$PIPE" "$tmp_f" >/dev/null 2>&1
            exit 0
        else
            video=$(find "$DOWNLOAD_PATH" -type f -name "$title.*" | grep -v "$title.\(json\|info.json\|jpg\|log\|fail.log\)")
            [ -f "$video" ] && embed "$video" "$json_f" "$thumbjpg" || return 1
            cleanup "$PIPE" "$tmp_f" >/dev/null 2>&1
            exit 0 ; 
        fi
    fi
fi

exit 0
